angular.module("jgefroh.AlertModule", []).constant("truncateLimit", 80), angular.module("jgefroh.FiltersModule", []), 
angular.module("ToDoList.SplashModule", []), angular.module("ToDoList.StatsModule", []), 
function() {
    angular.module("ToDoList.TaskModule", []);
}(), angular.module("ToDoList.PlannerModule", []), function() {
    angular.module("jgefroh.WidgetModule", []);
}(), function() {
    function AlertDirective(AlertService) {
        function AlertDirectiveCtrl($scope) {
            $scope.alert = AlertService.getAlert();
        }
        return {
            restrict: "A",
            scope: {},
            templateUrl: "modules/alert/AlertPanel.html",
            controller: [ "$scope", AlertDirectiveCtrl ]
        };
    }
    angular.module("jgefroh.AlertModule").directive("alertPanel", [ "AlertService", AlertDirective ]);
}(), function() {
    function AlertService($timeout) {
        var alert = {
            subject: "DEFAULT_TEXT_TO_AVOID_COLLAPSING",
            message: "DEFAULT_TEXT_TO_AVOID_COLLAPSING",
            type: null,
            isShowing: !1
        }, alertPanelTimer = null;
        this.getAlert = function() {
            return alert;
        }, this.setAlert = function(type, subject, message, timeout) {
            alert.type = type, alert.subject = subject, alert.message = message, alert.isShowing = !0, 
            null != alertPanelTimer && $timeout.cancel(alertPanelTimer), alertPanelTimer = $timeout(function() {
                alert.isShowing = !1, alertPanelTimer = null;
            }, timeout);
        };
    }
    angular.module("jgefroh.AlertModule").service("AlertService", [ "$timeout", AlertService ]);
}(), function() {
    function ViewState() {
        return {
            remainingTaskViewState: {
                isAscending: null,
                sortField: null,
                isShowingMinutes: null,
                tagsToFilterBy: [],
                input: {
                    name: null,
                    group: null
                }
            },
            completedTaskViewState: {
                isAscending: null,
                sortField: null,
                isShowingMinutes: null,
                tagsToFilterBy: []
            },
            statisticsViewState: {
                isAscending: null,
                sortField: null,
                isShowingMinutes: null
            },
            taskCreationViewState: {},
            calendarViewState: {
                selectedDate: new Date(),
                isShowingScheduled: !0,
                tagsToFilterBy: [],
                input: {
                    name: null,
                    timestampDue: new Date()
                }
            }
        };
    }
    angular.module("ToDoList.ViewStateModule", []).service("ViewState", ViewState);
}(), function() {
    function TagFilter() {
        return function(tasks, tagsToFilterBy) {
            return tasks && tagsToFilterBy ? 0 === tagsToFilterBy.length ? tasks : tasks.filter(function(task) {
                var isIncluded = !1;
                return angular.forEach(task.tags, function(taskTag) {
                    angular.forEach(tagsToFilterBy, function(filterTag) {
                        filterTag === taskTag && (isIncluded = !0);
                    });
                }), isIncluded;
            }) : tasks;
        };
    }
    angular.module("jgefroh.FiltersModule").filter("tagFilter", TagFilter);
}(), function() {
    function MSToHoursFilter() {
        return function(timeToConvertInMS, numberDecimalPositions) {
            var hours = timeToConvertInMS / 6e4 / 60;
            return numberDecimalPositions ? hours.toFixed(numberDecimalPositions) : hours;
        };
    }
    function MSToMinutesFilter() {
        return function(timeToConvertInMS, numberDecimalPositions) {
            return (timeToConvertInMS / 6e4).toFixed(numberDecimalPositions);
        };
    }
    function HoursToMSFilter() {
        return function(timeToConvertInHours) {
            return 6e4 * timeToConvertInHours * 60;
        };
    }
    angular.module("jgefroh.FiltersModule").filter("msToHours", MSToHoursFilter).filter("msToMinutes", MSToMinutesFilter).filter("hoursToMS", HoursToMSFilter);
}(), function() {
    function NavigationCtrl(TaskService, StatsService, $location, applicationName, versionNumber, UserService) {
        var vm = this;
        vm.user = UserService.user, vm.applicationName = applicationName, vm.versionNumber = versionNumber, 
        vm.getTasks = function() {
            TaskService.getTasks(UserService.user.id).then(function(tasks) {
                vm.tasks = tasks;
            });
        }, vm.goTo = function(route) {
            $location.path(route);
        }, vm.requestStatUpdate = function() {
            StatsService.requestStatUpdate();
        }, vm.isActive = function(route) {
            return $location.path() === route || 0 === $location.path().indexOf(route);
        };
    }
    angular.module("ToDoList.NavigationModule", []).controller("NavigationCtrl", [ "TaskService", "StatsService", "$location", "applicationName", "versionNumber", "UserService", NavigationCtrl ]);
}(), function() {
    function UserService($q, $http, $stateParams) {
        var self = this, endpoints = {
            getID: function() {
                return "../rest/security";
            }
        };
        this.user = {
            id: $stateParams.userID
        }, this.reserveID = function(userID) {
            var deferred = $q.defer();
            return userID && "newuser" !== userID ? ($stateParams.userID = userID, self.user.id = userID, 
            deferred.resolve(self.user.id)) : $http.get(endpoints.getID()).then(function(response) {
                $stateParams.userID = response.data, self.user.id = response.data, deferred.resolve(self.user.id);
            }), deferred.promise;
        };
    }
    angular.module("ToDoList.SecurityModule", []).service("UserService", [ "$q", "$http", "$stateParams", UserService ]);
}(), function() {
    function SplashCtrl($state, UserService) {
        function initialize() {
            UserService.reserveID($state.params.userID).then(function(id) {
                vm.params.userID = id;
            });
        }
        var vm = this;
        vm.user = UserService.user, vm.params = $state.params, vm.goToRemaining = function() {
            $state.go("remaining", {
                userID: vm.params.userID
            });
        }, vm.useId = function(userID) {
            UserService.reserveID(userID);
        }, initialize();
    }
    angular.module("ToDoList.StatsModule").controller("SplashCtrl", [ "$state", "UserService", SplashCtrl ]);
}(), function() {
    function StatsService($http) {
        var endpoints = {
            getStatsByGroup: function(ownerId) {
                return "../rest/stats/byGroup?ownerId={ownerId}".replace("{ownerId}", ownerId);
            },
            getStatsByTag: function(ownerId) {
                return "../rest/stats/byTag?ownerId={ownerId}".replace("{ownerId}", ownerId);
            }
        };
        this.getStatsByGroup = function(ownerId) {
            return $http.get(endpoints.getStatsByGroup(ownerId)).then(function(response) {
                return response.data;
            });
        }, this.getStatsByTag = function(ownerId) {
            return $http.get(endpoints.getStatsByTag(ownerId)).then(function(response) {
                return response.data;
            });
        };
    }
    angular.module("ToDoList.StatsModule").service("StatsService", [ "$http", StatsService ]);
}(), function() {
    function TaskStatisticsCtrl($scope, $timeout, ViewState, StatsService, $stateParams, UserService) {
        function initialize() {
            UserService.reserveID($stateParams.userID), vm.operations = {
                getStatsByGroup: {
                    status: null
                },
                getStatsByTag: {
                    status: null
                }
            }, initializeViewState(), initializeStatUpdaterSentinel(), initializeStatUpdater(), 
            vm.getStatsByGroup(), vm.getStatsByTag();
        }
        function initializeViewState() {
            vm.viewState = ViewState.statisticsViewState;
        }
        function initializeStatUpdaterSentinel() {
            $scope.$on("$destroy", function() {
                isDestroyed = !0;
            });
        }
        function initializeStatUpdater() {
            $timeout(function() {
                isDestroyed || (StatsService.getStatsByGroup(UserService.user.id).then(function(statsByGroup) {
                    vm.statsByGroup = statsByGroup;
                }), StatsService.getStatsByTag(UserService.user.id).then(function(statsByTag) {
                    vm.statsByTag = statsByTag;
                }), initializeStatUpdater());
            }, TRACKED_TIME_UPDATE_INTERVAL_IN_MS);
        }
        var vm = this, TRACKED_TIME_UPDATE_INTERVAL_IN_MS = 6e4, isDestroyed = !1;
        vm.getStatsByGroup = function() {
            vm.operations.getStatsByGroup.status = "LOADING", StatsService.getStatsByGroup(UserService.user.id).then(function(statsByGroup) {
                vm.operations.getStatsByGroup.status = null, vm.statsByGroup = statsByGroup;
            }).catch(function() {
                vm.operations.getStatsByGroup.status = "ERROR";
            });
        }, vm.getStatsByTag = function() {
            vm.operations.getStatsByTag.status = "LOADING", StatsService.getStatsByTag(UserService.user.id).then(function(statsByTag) {
                vm.operations.getStatsByTag.status = null, vm.statsByTag = statsByTag;
            }).catch(function() {
                vm.operations.getStatsByTag.status = "ERROR";
            });
        }, initialize();
    }
    angular.module("ToDoList.StatsModule").controller("TaskStatisticsCtrl", [ "$scope", "$timeout", "ViewState", "StatsService", "$stateParams", "UserService", TaskStatisticsCtrl ]);
}(), function() {
    function TaskService($http, $q) {
        function isValidInput(taskName, taskGroup) {
            return taskName || taskGroup;
        }
        var endpoints = {
            getTasks: function(ownerId, completed) {
                var url = "../rest/tasks?ownerId={ownerId}".replace("{ownerId}", ownerId);
                return completed === !0 || completed === !1 ? url + "&completed={completed}".replace("{completed}", completed) : url;
            },
            saveTask: function(ownerId) {
                return "../rest/tasks?ownerId={ownerId}".replace("{ownerId}", ownerId);
            },
            deleteTask: function(ownerId, taskId) {
                return "../rest/tasks/{taskId}/{ownerId}".replace("{taskId}", taskId).replace("{ownerId}", ownerId);
            },
            markComplete: function(ownerId, taskId) {
                return "../rest/tasks/{taskId}/{ownerId}/markComplete".replace("{taskId}", taskId).replace("{ownerId}", ownerId);
            },
            markIncomplete: function(ownerId, taskId) {
                return "../rest/tasks/{taskId}/{ownerId}/markIncomplete".replace("{taskId}", taskId).replace("{ownerId}", ownerId);
            },
            trackTask: function(ownerId, taskId) {
                return "../rest/tasks/{taskId}/{ownerId}/track".replace("{taskId}", taskId).replace("{ownerId}", ownerId);
            },
            untrackTask: function(ownerId, taskId) {
                return "../rest/tasks/{taskId}/{ownerId}/untrack".replace("{taskId}", taskId).replace("{ownerId}", ownerId);
            }
        };
        this.saveTask = function(ownerId, task) {
            var deferred = $q.defer();
            return task && isValidInput(task.name, task.group) ? $http.put(endpoints.saveTask(ownerId), task).then(function(response) {
                return response.data;
            }) : (deferred.reject(), deferred.promise);
        }, this.deleteTask = function(ownerId, taskId) {
            return $http({
                method: "DELETE",
                url: endpoints.deleteTask(ownerId, taskId)
            }).then(function(response) {
                return response.data;
            });
        }, this.getTasks = function(ownerId, completed) {
            return $http.get(endpoints.getTasks(ownerId, completed)).then(function(response) {
                return response.data;
            });
        }, this.markComplete = function(ownerId, taskId) {
            return $http.put(endpoints.markComplete(ownerId, taskId)).then(function(response) {
                return response.data;
            });
        }, this.markIncomplete = function(ownerId, taskId) {
            return $http.put(endpoints.markIncomplete(ownerId, taskId)).then(function(response) {
                return response.data;
            });
        }, this.trackTask = function(ownerId, taskId) {
            return $http.put(endpoints.trackTask(ownerId, taskId)).then(function(response) {
                return response.data;
            });
        }, this.untrackTask = function(ownerId, taskId) {
            return $http.put(endpoints.untrackTask(ownerId, taskId)).then(function(response) {
                return response.data;
            });
        }, this.approximateTotalTimeTracked = function(task) {
            if (task.tracking) {
                var fakeTotalTimeTracked = new Date() - task.timestampTrackingStarted + task.totalTimeTracked;
                task.timestampTrackingStarted = new Date(), task.totalTimeTracked = fakeTotalTimeTracked;
            }
        }, this.getUsedTags = function(tasks) {
            var usedTags = [];
            return angular.forEach(tasks, function(task) {
                angular.forEach(task.tags, function(tag) {
                    -1 === usedTags.indexOf(tag) && usedTags.push(tag);
                });
            }), usedTags;
        }, this.isUnscheduledTask = function(task) {
            return !task.timestampDue && !task.complete;
        };
    }
    angular.module("ToDoList.TaskModule").service("TaskService", [ "$http", "$q", "$timeout", "$stateParams", "UserService", TaskService ]);
}(), function() {
    function TagDisplayDirective() {
        function TagDisplayDirectiveCtrl($scope) {
            $scope.toggleTagFilter = function(tag) {
                -1 === $scope.tagsToFilterBy.indexOf(tag) ? $scope.tagsToFilterBy.push(tag) : $scope.tagsToFilterBy.splice($scope.tagsToFilterBy.indexOf(tag), 1);
            };
        }
        return {
            restrict: "A",
            scope: {
                tags: "=",
                tagsToFilterBy: "="
            },
            templateUrl: "modules/task/common/TagDisplay.html",
            controller: [ "$scope", TagDisplayDirectiveCtrl ]
        };
    }
    angular.module("ToDoList.TaskModule").directive("tagDisplay", [ TagDisplayDirective ]);
}(), function() {
    function CompletedTasksCtrl(ViewState, TaskService, AlertService, truncateLimit, $filter, $stateParams, UserService) {
        function updateTags() {
            updateUsedTags(), updateFilterTags();
        }
        function updateUsedTags() {
            vm.usedTags = TaskService.getUsedTags($filter("filter")(vm.tasks, {
                complete: !0
            }));
        }
        function updateFilterTags() {
            var tagsToKeep = [];
            angular.forEach(vm.viewState.tagsToFilterBy, function(filterTag) {
                -1 !== vm.usedTags.indexOf(filterTag) && tagsToKeep.push(filterTag);
            }), vm.viewState.tagsToFilterBy = tagsToKeep;
        }
        function initialize() {
            UserService.reserveID($stateParams.userID), initializeViewState(), vm.getTasks();
        }
        function initializeViewState() {
            vm.viewState = ViewState.completedTaskViewState, vm.viewState.sortField || (vm.viewState.sortField = {
                value: "timestampCompleted",
                label: "Date Completed"
            });
        }
        var vm = this;
        vm.operations = {
            getTasks: {
                status: null
            },
            markIncomplete: {
                tasks: {},
                status: null
            },
            deleteTask: {
                tasks: {},
                status: null
            }
        }, vm.getTasks = function() {
            vm.operations.getTasks.status = "LOADING", TaskService.getTasks(UserService.user.id, !0).then(function(tasks) {
                vm.operations.getTasks.status = null, vm.tasks = tasks, updateTags();
            }).catch(function() {
                vm.operations.getTasks.status = "ERROR", console.error("An error occured while loading tasks.");
            });
        }, vm.getUniqueGroups = function() {
            vm.uniqueGroups = {};
            var completedTasks = $filter("filter")(vm.tasks, {
                complete: !0
            }), filteredCompletedTasks = $filter("tagFilter")(completedTasks, vm.viewState.tagsToFilterBy);
            return angular.forEach(filteredCompletedTasks, function(task) {
                vm.uniqueGroups[task.group] = task.group;
            }), vm.uniqueGroups;
        }, vm.deleteTask = function(task) {
            task.readOnly = !0, vm.operations.deleteTask.tasks[task.id] = {
                status: "LOADING"
            }, TaskService.deleteTask(UserService.user.id, task.id).then(function() {
                delete vm.operations.deleteTask.tasks[task.id], null != task.name ? AlertService.setAlert("alert-danger", "Task Deleted!", $filter("limitTo")(task.name, truncateLimit) + " has been deleted.", 2e3) : AlertService.setAlert("alert-danger", "Task Deleted!", "A task has been marked deleted.", 2e3);
                var index = vm.tasks.indexOf(task);
                vm.tasks.splice(index, 1), updateTags();
            }).catch(function() {
                vm.operations.deleteTask.tasks[task.id].status = "ERROR", console.error("An error occurred while deleting this task.");
            }).finally(function() {
                task.readOnly = !1;
            });
        }, vm.markIncomplete = function(task) {
            task.readOnly = !0, vm.operations.markIncomplete.tasks[task.id] = {
                status: "LOADING"
            }, TaskService.markIncomplete(UserService.user.id, task.id).then(function(incompleteTask) {
                delete vm.operations.markIncomplete.tasks[task.id], angular.copy(incompleteTask, task), 
                null != task.name ? AlertService.setAlert("alert-warning", "Task Incomplete!", $filter("limitTo")(task.name, truncateLimit) + " has been marked as incomplete.", 2e3) : AlertService.setAlert("alert-warning", "Task Incomplete!", "A task has been marked as incomplete.", 2e3), 
                updateTags();
            }).catch(function() {
                vm.operations.markIncomplete.tasks[task.id].status = "ERROR", console.error("An error occurred while marking task as incomplete.");
            }).finally(function() {
                task.readOnly = !1;
            });
        }, initialize();
    }
    angular.module("ToDoList.TaskModule").controller("CompletedTasksCtrl", [ "ViewState", "TaskService", "AlertService", "truncateLimit", "$filter", "$stateParams", "UserService", CompletedTasksCtrl ]);
}(), function() {
    function TaskModificationCtrl($scope, $modalInstance, $filter, UserService, TaskService, editedTask, options) {
        function assignOrderTo(subtasks) {
            angular.forEach(subtasks, function(subtask, index) {
                subtask.order = index;
            });
        }
        function initialize() {
            $scope.form = {}, $scope.options = options, $scope.operations = {
                editTask: {}
            }, $scope.inputCopy = angular.copy(editedTask), $scope.shadowInput = angular.copy(editedTask), 
            $scope.shadowInput.totalTimeTrackedAsHours = $filter("msToHours")($scope.inputCopy.totalTimeTracked);
        }
        var ENTER_KEY_ID = 13;
        $scope.saveTask = function(taskFields) {
            $scope.addTag($scope.form.tag), $scope.addSubtask($scope.form.subtaskName), assignOrderTo(taskFields.subtasks), 
            $scope.operations.editTask.status = "LOADING", TaskService.saveTask(UserService.user.id, taskFields).then(function(savedTask) {
                $scope.operations.editTask.status = null, $modalInstance.close(savedTask), $scope.inputCopy = null;
            }).catch(function() {
                $scope.operations.editTask.status = "ERROR", console.error("An error occurred while saving a task.");
            });
        }, $scope.addTagOnEnterKeyPressed = function(tag, key) {
            key.which === ENTER_KEY_ID && $scope.addTag(tag);
        }, $scope.addTag = function(tag) {
            $scope.inputCopy.tags || ($scope.inputCopy.tags = []), tag && -1 === $scope.inputCopy.tags.indexOf(tag) && $scope.inputCopy.tags.push(tag), 
            $scope.form.tag = null;
        }, $scope.removeTag = function(tag) {
            $scope.inputCopy.tags.splice($scope.inputCopy.tags.indexOf(tag), 1);
        }, $scope.addSubtaskOnEnterKeyPressed = function(subtask, key) {
            key.which === ENTER_KEY_ID && $scope.addSubtask(subtask);
        }, $scope.addSubtask = function(subtaskName) {
            $scope.inputCopy.subtasks || ($scope.inputCopy.subtasks = []);
            var subtask = {
                name: subtaskName,
                parentTaskId: $scope.inputCopy.id
            };
            subtask.name && ($scope.inputCopy.subtasks.push(subtask), $scope.form.subtaskName = null);
        }, $scope.removeSubtask = function(subtask) {
            $scope.inputCopy.subtasks.splice($scope.inputCopy.subtasks.indexOf(subtask), 1);
        }, $scope.increaseSubtaskPriority = function(subtask) {
            var currentIndex = $scope.inputCopy.subtasks.indexOf(subtask);
            $scope.inputCopy.subtasks.splice(currentIndex - 1, 0, $scope.inputCopy.subtasks.splice(currentIndex, 1)[0]);
        }, $scope.decreaseSubtaskPriority = function(subtask) {
            var currentIndex = $scope.inputCopy.subtasks.indexOf(subtask);
            $scope.inputCopy.subtasks.splice(currentIndex + 1, 0, $scope.inputCopy.subtasks.splice(currentIndex, 1)[0]);
        }, $scope.cancel = function() {
            $modalInstance.dismiss("cancel");
        }, initialize();
    }
    angular.module("ToDoList.TaskModule").controller("TaskModificationCtrl", [ "$scope", "$modalInstance", "$filter", "UserService", "TaskService", "editedTask", "options", TaskModificationCtrl ]);
}(), function() {
    function PlannerController($state) {
        var vm = this;
        vm.isShowing = function(view) {
            return $state.includes(view);
        }, vm.goTo = function(place) {
            $state.go(place);
        };
    }
    angular.module("ToDoList.PlannerModule").controller("PlannerCtrl", [ "$state", PlannerController ]);
}(), function() {
    function TaskCalendarCtrl(ViewState, UserService, $stateParams, $modal, TaskService, AlertService, $filter, truncateLimit) {
        function resetInputFields(taskFields) {
            taskFields.name = null;
        }
        function updateTags() {
            updateUsedTags(), updateFilterTags();
        }
        function updateUsedTags() {
            vm.usedTags = TaskService.getUsedTags(vm.tasks);
        }
        function updateFilterTags() {
            var tagsToKeep = [];
            angular.forEach(vm.viewState.tagsToFilterBy, function(filterTag) {
                -1 !== vm.usedTags.indexOf(filterTag) && tagsToKeep.push(filterTag);
            }), vm.viewState.tagsToFilterBy = tagsToKeep;
        }
        function initialize() {
            UserService.reserveID($stateParams.userID), initializeViewState(), initializeVariables(), 
            vm.loadDatesOfMonth(new Date()), vm.getTasks();
        }
        function initializeViewState() {
            vm.viewState = ViewState.calendarViewState;
        }
        function initializeVariables() {
            vm.operations = {
                addTask: {},
                getTasks: {},
                markComplete: {
                    tasks: {},
                    status: null
                },
                markIncomplete: {
                    tasks: {},
                    status: null
                }
            }, vm.monthSelectorAPI = {};
        }
        var vm = this, ENTER_KEY_ID = 13, SATURDAY = 6, SUNDAY = 0;
        vm.isUnscheduledTask = TaskService.isUnscheduledTask, vm.getTasks = function() {
            vm.operations.getTasks.status = "LOADING", TaskService.getTasks(UserService.user.id).then(function(tasks) {
                vm.operations.getTasks.status = null, vm.tasks = tasks, updateTags();
            }).catch(function() {
                vm.operations.getTasks.status = "ERROR", console.error("An error occured while loading tasks.");
            });
        }, vm.getTasksOnDate = function(date) {
            var tasksOnDate = [];
            return angular.forEach(vm.tasks, function(task) {
                if (task.timestampDue) {
                    var taskDate = new Date(task.timestampDue);
                    date.getDate() === taskDate.getDate() && date.getYear() === taskDate.getYear() && date.getMonth() === taskDate.getMonth() && tasksOnDate.push(task);
                }
            }), tasksOnDate;
        }, vm.loadDatesOfMonth = function(date) {
            if (date) {
                var year = date.getUTCFullYear(), month = date.getUTCMonth();
                vm.datesOfMonth || (vm.datesOfMonth = []), vm.datesOfMonth.length = 0;
                for (var numDaysInMonth = new Date(year, month + 1, 0).getDate(), day = 0; numDaysInMonth > day; day++) vm.datesOfMonth.push(new Date(year, month, day + 1));
            }
        }, vm.isWeekend = function(date) {
            return date.getDay() === SATURDAY || date.getDay() === SUNDAY;
        }, vm.addTaskOnEnterKeyPressed = function(taskFields, key) {
            key.which === ENTER_KEY_ID && vm.addTask(taskFields);
        }, vm.addTask = function(taskFields) {
            vm.operations.addTask.status = "LOADING", taskFields.tags = angular.copy(vm.viewState.tagsToFilterBy), 
            TaskService.saveTask(UserService.user.id, taskFields).then(function(task) {
                vm.operations.addTask.status = null, vm.tasks.push(task), resetInputFields(taskFields), 
                null != task.name ? AlertService.setAlert("alert-info", "Task Added!", $filter("limitTo")(task.name, truncateLimit) + " has been added.", 2e3) : AlertService.setAlert("alert-info", "Task Added!", "A task has been added to your list.", 2e3);
            }).catch(function() {
                vm.operations.addTask.status = "ERROR", console.error("An error occurred while adding task.");
            });
        }, vm.markComplete = function(task) {
            task.readOnly = !0, vm.operations.markComplete.tasks[task.id] = {
                status: "LOADING"
            }, TaskService.markComplete(UserService.user.id, task.id).then(function(completedTask) {
                delete vm.operations.markComplete.tasks[task.id], angular.copy(completedTask, task);
            }).catch(function() {
                vm.operations.markComplete.tasks[task.id].status = "ERROR", console.error("An error occurred while completing task.");
            }).finally(function() {
                task.readOnly = !1;
            });
        }, vm.markIncomplete = function(task) {
            task.readOnly = !0, vm.operations.markIncomplete.tasks[task.id] = {
                status: "LOADING"
            }, TaskService.markIncomplete(UserService.user.id, task.id).then(function(incompleteTask) {
                delete vm.operations.markIncomplete.tasks[task.id], angular.copy(incompleteTask, task);
            }).catch(function() {
                vm.operations.markIncomplete.tasks[task.id].status = "ERROR", console.error("An error occurred while marking task as incomplete.");
            }).finally(function() {
                task.readOnly = !1;
            });
        }, vm.showEditTask = function(task) {
            var modal = $modal.open({
                templateUrl: "modules/task/planner/calendar/../../modification/TaskModification.html",
                controller: "TaskModificationCtrl",
                controllerAs: "modificationCtrl",
                resolve: {
                    editedTask: function() {
                        return task;
                    },
                    options: function() {
                        return {
                            layout: "SCHEDULE"
                        };
                    }
                }
            });
            modal.result.then(function(savedTask) {
                savedTask.timestampDue && !task.timestampDue ? AlertService.setAlert("alert-info", "Task Scheduled!", $filter("limitTo")(task.name || "A task", truncateLimit) + " has been scheduled.", 2e3) : !savedTask.timestampDue && task.timestampDue && AlertService.setAlert("alert-info", "Task Unscheduled!", $filter("limitTo")(task.name || "A task", truncateLimit) + " has been unscheduled.", 2e3), 
                angular.copy(savedTask, task), updateTags();
            });
        }, vm.isToday = function(date) {
            var today = new Date();
            return today.getDate() === date.getDate() && today.getMonth() === date.getMonth() && today.getFullYear() === date.getFullYear();
        }, initialize();
    }
    angular.module("ToDoList.PlannerModule").controller("TaskCalendarCtrl", [ "ViewState", "UserService", "$stateParams", "$modal", "TaskService", "AlertService", "$filter", "truncateLimit", TaskCalendarCtrl ]);
}(), function() {
    function RemainingTasksCtrl($scope, $timeout, $modal, $sce, ViewState, UserService, $stateParams, TaskService, AlertService, truncateLimit, $filter, $rootScope) {
        function showEdit(task, layout) {
            var modal = $modal.open({
                templateUrl: "modules/task/remaining/../modification/TaskModification.html",
                controller: "TaskModificationCtrl",
                controllerAs: "modificationCtrl",
                resolve: {
                    editedTask: function() {
                        return task;
                    },
                    options: function() {
                        return {
                            layout: layout
                        };
                    }
                }
            });
            modal.result.then(function(savedTask) {
                angular.copy(savedTask, task), updateTags();
            });
        }
        function updateTags() {
            updateUsedTags(), updateFilterTags();
        }
        function updateUsedTags() {
            vm.usedTags = TaskService.getUsedTags($filter("filter")(vm.tasks, {
                complete: !1
            }));
        }
        function updateFilterTags() {
            var tagsToKeep = [];
            angular.forEach(vm.viewState.tagsToFilterBy, function(filterTag) {
                -1 !== vm.usedTags.indexOf(filterTag) && tagsToKeep.push(filterTag);
            }), vm.viewState.tagsToFilterBy = tagsToKeep;
        }
        function resetInputFields(taskFields) {
            taskFields.name = null;
        }
        function initialize() {
            UserService.reserveID($stateParams.userID), vm.datePickerConfig = {}, initializeViewState(), 
            initializeModalWatcher(), initializeTimeTrackedUpdater(), vm.getTasks();
        }
        function initializeViewState() {
            vm.viewState = ViewState.remainingTaskViewState, vm.viewState.sortField || (vm.viewState.sortField = {
                value: "timestampCreated",
                label: "Date Added"
            });
        }
        function initializeModalWatcher() {
            var modalWatcherHandler = $rootScope.$on("$locationChangeStart", function() {
                var modalBackdrop = $jQuery(".modal-backdrop");
                modalBackdrop && modalBackdrop.remove();
            });
            $scope.$on("$destroy", function() {
                isDestroyed = !0, modalWatcherHandler();
            });
        }
        function initializeTimeTrackedUpdater() {
            $timeout(function() {
                isDestroyed || (angular.forEach(vm.tasks, function(task) {
                    TaskService.approximateTotalTimeTracked(task);
                }), initializeTimeTrackedUpdater());
            }, TRACKED_TIME_UPDATE_INTERVAL_IN_MS);
        }
        var vm = this, ENTER_KEY_ID = 13, TRACKED_TIME_UPDATE_INTERVAL_IN_MS = 3e4, isDestroyed = !1;
        vm.operations = {
            addTask: {
                status: null
            },
            getTasks: {
                status: null
            },
            editTask: {
                status: null
            },
            markComplete: {
                tasks: {},
                status: null
            },
            markIncomplete: {
                tasks: {},
                status: null
            },
            trackingUntracking: {
                tasks: {},
                status: null
            }
        }, vm.getTasks = function() {
            vm.operations.getTasks.status = "LOADING", TaskService.getTasks(UserService.user.id, !1).then(function(tasks) {
                vm.operations.getTasks.status = null, vm.tasks = tasks, updateTags();
            }).catch(function() {
                vm.operations.getTasks.status = "ERROR", console.error("An error occured while loading tasks.");
            });
        }, vm.getUniqueGroups = function() {
            vm.uniqueGroups = {};
            var completedTasks = $filter("filter")(vm.tasks, {
                complete: !1
            }), filteredCompletedTasks = $filter("tagFilter")(completedTasks, vm.viewState.tagsToFilterBy);
            return angular.forEach(filteredCompletedTasks, function(task) {
                vm.uniqueGroups[task.group] = task.group;
            }), vm.uniqueGroups;
        }, vm.addTaskOnEnterKeyPressed = function(taskFields, key) {
            key.which === ENTER_KEY_ID && vm.addTask(taskFields);
        }, vm.addTask = function(taskFields) {
            vm.operations.addTask.status = "LOADING", taskFields.tags = angular.copy(vm.viewState.tagsToFilterBy), 
            TaskService.saveTask(UserService.user.id, taskFields).then(function(task) {
                vm.operations.addTask.status = null, vm.tasks.push(task), resetInputFields(taskFields), 
                null != task.name ? AlertService.setAlert("alert-info", "Task Added!", $filter("limitTo")(task.name, truncateLimit) + " has been added.", 2e3) : AlertService.setAlert("alert-info", "Task Added!", "A task has been added to your list.", 2e3);
            }).catch(function() {
                vm.operations.addTask.status = "ERROR", console.error("An error occured while adding task.");
            });
        }, vm.showEditSubtask = function(task) {
            showEdit(task, "SUBTASK");
        }, vm.showEditTask = function(task) {
            showEdit(task, "FULL");
        }, vm.markComplete = function(task) {
            task.readOnly = !0, vm.operations.markComplete.tasks[task.id] = {
                status: "LOADING"
            }, TaskService.markComplete(UserService.user.id, task.id).then(function(completedTask) {
                delete vm.operations.markComplete.tasks[task.id], angular.copy(completedTask, task), 
                null != task.name ? AlertService.setAlert("alert-success", "Task Complete!", $filter("limitTo")(task.name, truncateLimit) + " has been marked as complete.", 2e3) : AlertService.setAlert("alert-success", "Task Complete!", "A task has been marked as complete.", 2e3), 
                updateTags();
            }).catch(function() {
                vm.operations.markComplete.tasks[task.id].status = "ERROR", console.error("An error occurred while completing task.");
            }).finally(function() {
                task.readOnly = !1;
            });
        }, vm.markIncomplete = function(task) {
            task.readOnly = !0, vm.operations.markIncomplete.tasks[task.id] = {
                status: "LOADING"
            }, TaskService.markIncomplete(UserService.user.id, task.id).then(function(completedTask) {
                delete vm.operations.markIncomplete.tasks[task.id], angular.copy(completedTask, task), 
                null != task.name ? AlertService.setAlert("alert-success", "Task Complete!", $filter("limitTo")(task.name, truncateLimit) + " has been marked as incomplete.", 2e3) : AlertService.setAlert("alert-success", "Task Complete!", "A task has been marked as incomplete.", 2e3), 
                updateTags();
            }).catch(function() {
                vm.operations.markIncomplete.tasks[task.id].status = "ERROR", console.error("An error occurred while marking task as incomplete.");
            }).finally(function() {
                task.readOnly = !1;
            });
        }, vm.startTrackingTask = function(task) {
            task.readOnly = !0, vm.operations.trackingUntracking.tasks[task.id] = {
                status: "LOADING"
            }, TaskService.trackTask(UserService.user.id, task.id).then(function(trackedTask) {
                delete vm.operations.trackingUntracking.tasks[task.id], angular.copy(trackedTask, task);
            }).catch(function() {
                vm.operations.trackingUntracking.tasks[task.id].status = "ERROR";
            }).finally(function() {
                task.readOnly = !1;
            });
        }, vm.stopTrackingTask = function(task) {
            task.readOnly = !0, vm.operations.trackingUntracking.tasks[task.id] = {
                status: "LOADING"
            }, TaskService.untrackTask(UserService.user.id, task.id).then(function(untrackedTask) {
                delete vm.operations.trackingUntracking.tasks[task.id], angular.copy(untrackedTask, task);
            }).catch(function() {
                vm.operations.trackingUntracking.tasks[task.id].status = "ERROR";
            }).finally(function() {
                task.readOnly = !1;
            });
        }, vm.trustHTML = function(text) {
            return $sce.trustAsHtml(text);
        }, initialize();
    }
    var $jQuery = jQuery.noConflict();
    angular.module("ToDoList.TaskModule").controller("RemainingTasksCtrl", [ "$scope", "$timeout", "$modal", "$sce", "ViewState", "UserService", "$stateParams", "TaskService", "AlertService", "truncateLimit", "$filter", "$rootScope", RemainingTasksCtrl ]);
}(), function() {
    function DateInputField() {
        function DateInputFieldController($scope) {
            $scope.open = function(event) {
                event.preventDefault(), event.stopPropagation(), $scope.isOpen = !0;
            };
        }
        return {
            restrict: "A",
            scope: {
                model: "=",
                config: "=",
                isDisabled: "="
            },
            templateUrl: "modules/widgets/DateInputField.html",
            controller: [ "$scope", DateInputFieldController ]
        };
    }
    angular.module("jgefroh.WidgetModule").directive("dateInputField", DateInputField);
}(), function() {
    function MonthSelector() {
        function MonthSelectorController($scope) {
            function initializeAPI() {
                $scope.api && ($scope.api.getFullMonth = function(monthIndex) {
                    return !monthIndex && 0 !== monthIndex || 0 > monthIndex || monthIndex > 11 ? null : $scope.monthButtons[monthIndex].full;
                });
            }
            $scope.viewState.selectedMonthIndex || ($scope.viewState.selectedMonthIndex = new Date().getMonth(), 
            $scope.viewState.selectedYear = new Date().getUTCFullYear()), $scope.monthButtons = [ {
                id: 0,
                label: "Jan",
                full: "January"
            }, {
                id: 1,
                label: "Feb",
                full: "February"
            }, {
                id: 2,
                label: "Mar",
                full: "March"
            }, {
                id: 3,
                label: "Apr",
                full: "April"
            }, {
                id: 4,
                label: "May",
                full: "May"
            }, {
                id: 5,
                label: "Jun",
                full: "June"
            }, {
                id: 6,
                label: "Jul",
                full: "July"
            }, {
                id: 7,
                label: "Aug",
                full: "August"
            }, {
                id: 8,
                label: "Sep",
                full: "September"
            }, {
                id: 9,
                label: "Oct",
                full: "October"
            }, {
                id: 10,
                label: "Nov",
                full: "November"
            }, {
                id: 11,
                label: "Dec",
                full: "December"
            } ], $scope.previousMonth = function() {
                0 === $scope.viewState.selectedMonthIndex ? ($scope.viewState.selectedMonthIndex = 11, 
                $scope.viewState.selectedYear--) : $scope.viewState.selectedMonthIndex--, $scope.viewState.selectedDate = $scope.getDate($scope.viewState.selectedYear, $scope.viewState.selectedMonthIndex), 
                $scope.onChange();
            }, $scope.nextMonth = function() {
                11 === $scope.viewState.selectedMonthIndex ? ($scope.viewState.selectedMonthIndex = 0, 
                $scope.viewState.selectedYear++) : $scope.viewState.selectedMonthIndex++, $scope.viewState.selectedDate = $scope.getDate($scope.viewState.selectedYear, $scope.viewState.selectedMonthIndex), 
                $scope.onChange();
            }, $scope.getDate = function(year, month) {
                return new Date(year, month);
            }, $scope.setMonth = function(monthIndex) {
                $scope.viewState.selectedMonthIndex = monthIndex, $scope.viewState.selectedDate = $scope.getDate($scope.viewState.selectedYear, $scope.viewState.selectedMonthIndex), 
                $scope.onChange();
            }, initializeAPI();
        }
        return {
            restrict: "A",
            scope: {
                viewState: "=",
                onChange: "&",
                api: "="
            },
            templateUrl: "modules/widgets/DateSelector.html",
            controller: [ "$scope", MonthSelectorController ]
        };
    }
    angular.module("jgefroh.WidgetModule").directive("dateSelector", MonthSelector);
}(), angular.module("ToDoList", [ "ui.router", "ui.bootstrap", "jgefroh.AlertModule", "jgefroh.FiltersModule", "jgefroh.WidgetModule", "ToDoList.Routes", "ToDoList.SecurityModule", "ToDoList.TaskModule", "ToDoList.StatsModule", "ToDoList.NavigationModule", "ToDoList.ViewStateModule", "ToDoList.SplashModule", "ToDoList.PlannerModule" ]), 
angular.module("ToDoList").constant("applicationName", "ToDoList").constant("versionNumber", "v2.1.8"), 
angular.module("ToDoList").controller("AppCtrl", [ "$state", function($state) {
    var vm = this;
    vm.isHidingAlerts = function() {
        return $state.current.data ? $state.current.data.isHidingAlerts : !1;
    };
} ]), function() {
    function Routes($stateProvider, $urlRouterProvider) {
        $stateProvider.state("splash", {
            url: "/splash/:userID",
            templateUrl: "modules/splash/Splash.html",
            controller: "SplashCtrl",
            controllerAs: "splashCtrl",
            data: {
                isHidingAlerts: !0
            }
        }).state("remaining", {
            url: "/remaining/:userID",
            templateUrl: "modules/task/remaining/RemainingTasks.html",
            controller: "RemainingTasksCtrl",
            controllerAs: "remainingCtrl"
        }).state("completed", {
            url: "/completed/:userID",
            templateUrl: "modules/task/completed/CompletedTasks.html",
            controller: "CompletedTasksCtrl",
            controllerAs: "completedCtrl"
        }).state("calendar", {
            url: "/calendar/:userID",
            templateUrl: "modules/task/planner/calendar/TaskCalendar.html",
            controller: "TaskCalendarCtrl",
            controllerAs: "calendarCtrl"
        }).state("planner", {
            url: "/planner",
            templateUrl: "modules/task/planner/PlannerView.html",
            controller: "PlannerCtrl",
            controllerAs: "plannerCtrl"
        }).state("planner.calendar", {
            url: "/calendar/:userID",
            templateUrl: "modules/task/planner/calendar/TaskCalendar.html",
            controller: "TaskCalendarCtrl",
            controllerAs: "calendarCtrl"
        }).state("statistics", {
            url: "/statistics/:userID",
            templateUrl: "modules/stats/TaskStatistics.html",
            controller: "TaskStatisticsCtrl",
            controllerAs: "statsCtrl"
        }), $urlRouterProvider.otherwise("/splash/");
    }
    angular.module("ToDoList.Routes", []).config([ "$stateProvider", "$urlRouterProvider", Routes ]);
}();